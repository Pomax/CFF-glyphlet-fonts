<!doctype html>
<html>

  <head>
    <meta charset="utf-8">
    <title>Font building</title>
    <link rel="stylesheet" href="style.css">
    <script src="require.js"></script>
    <!-- can't turn this into data-main, because then paths resolve completely wrong -->
    <script src="src/main.js"></script>
  </head>

  <body>
    <h1>A bit of font generation</h1>

    <p>Let's make a font that lets use type a letter with an outline shape defined by the SVG
       path "<span id="svg"></span>". We're going to have this shape sit in the spot of the tilde,
       "~", but because it might be more useful to have it automatically show up when we type
       a full word (like on <a hef="http://symbolset.com">symbolset.com</a>), we're also going
       to make it show up when we type the word "custom".</p>

    <p>Implementing this using a library to build custom single-glyph font, that font has actually
       just been built by your browser, and has been added as a webfont to this page (using a
       @font-face CSS rule and a styling class),  so let's see what your browser made of it.
       The character ~, with our font applied, is now styled as <span class="custom">~</span>,
       and the string "custom" is similarly styled (as ligature) as <span class="custom">custom</span>.
       Now, because this is essentially just in-font magic, copy-pasting the first rectangle
       should lead to you pasting the plain string "~", and copy-pasting the second rectangle
       should lead to you pasting the plain string "custom".</p>

    <h2>This is also how icon fonts work</h2>

    <p>So, we have a font that models "a shape", and we have a label that we can type that
       magically gets converted into that shape. Basically, this is how every (good) icon font
       that you've ever seen works. But, <em>how</em> do they work? Let's dive in.</p>

    <h2>Let's look at the actual font layout.</h2>

    <p>The following two tables are the kind of thing you would normally see in a hex editor,
       if you were to load up a (really) small font file. On the left we see the font's bytecode
       in hexadecimal numbering, and on the right we see the "as best as we can show it" table of
       bytes-as-letters (based on the <a href="http://en.wikipedia.org/wiki/ISO/IEC_8859-1">iso
       8859-1 code page</a>). You can make out some words on the right like "name" and "License-free",
       but for the most part it kind of looks like gibberish. However, if you know how to read
       a font, this view holds no secrets: everything the font can do is right there, just
       written in a different language. It's not even obfuscated or compressed, it's literally
       just a different way of writing down a graph of numbers.</p>

    <div id="tables"></div>

    <h2>So what do the numbers tell us?</h2>

    <p>First of all, a little primer on how OpenType fonts work. A font file is actually a
       collection on "tables", each describing a different aspect of the font. Some contain
       information on the font's name, license text, who made it, etc. and some contain
       metrics information, like what the overall character height is, how many letters are
       in the font, etc. Of all the tables in a font (and there are a fair number), typically
       only one table will contain what you might think of as actual letters. In the little
       font on this page, that's the "CFF" table (a "compact font format" table). Looking
       at the font's bytecode we can tell (or, if you know how to read it) that of the
       1,372 bytes that our font takes up, only 211 bytes (D3 in hex, see if you can spot it)
       are taken up by the CFF table. That's... really not that much. What on earth is all
       the rest for?</p>

    <h3>OpenType is about describing <em>everything</em>.</h3>

    <p>The CFF table is to an OpenType font what a typeface is to a book: essential,
       but really not the part that makes a font special. What makes OpenType fonts
       special is that they describe every aspect that you might be able to think of
       when you think of putting letters together to form words. In addition to the
       obvious "this is what letters look like" information, OpenType fonts also specify
       things like the name of each letter that is available in the font, how much
       of the <a href="http://unicode.org">Unicode</a> standard the font implements,
       which horizontal and vertical metrics apply to which letters, exactly how
       the letters are arranged inside the font so that they can quickly be read
       out, what kind of font classifications apply (is it a fantasy font? is it
       bold face? is it fixed width? etc), what kind of memory allocation a printer
       needs to perform in order to be able to even load the font, etc. etc. etc.</p>

    <p>And then, there are the two most important tables a font can have: the GSUB
       and GPOS tables. These tables are used, respectively, to define all the
       substitutions that the font can perform and how to position letters in
       relation to each other.</p>

    <p>For instance, a font that uses GSUB might contain two
       different sets of the numbers 0 through 9, one set for "normal typesetting",
       and another for "when historically used versions" are required. In "the old
       days" you would need to use two separate fonts, with the old-style number
       font applied to each number in your text, but with a modern OpenType font,
       the font itself can do the substitutions and you don't need to worry about
       whether all the numbers got styled correctly. But it can also be used to
       substitute single letters, or multiple letters, with other single or
       multiple letters. <em>And</em> it can be used to change what letters look
       like depending on where in a word they are. That might sound weird, but
       Arabic has four different shapes for <em>each</em> letter, depending on
       whether it's on its own, or used at the start, middle, or end of a word.
       Good luck trying to do that with a bunch of separate fonts for each of
       the positions in a word.</p>

    <p>A font with GPOS (and in older OpenType fonts, the "kern" table), can
       make sure that letters are positioned correctly; both in terms of
       what looks nice (like moving a V a little closer to A in "AV", so that
       it doesn't look like there's "too much" space between them) but also
       to ensure things are correct, like forming the Vietnames letter á»Ÿ
       by combining the base letter "o" with the two diacritic marks
       required to make it the correct letter.</p>

    <p>Our little font only has one letter, so it doesn't use a GPOS table
       (what would we reposition?) but the GSUB table just for replacing
       "custom" with "~", is 98 bytes. That's almost half the size of the
       CFF table. So, why so big?</p>

    <p>Good reasons, actually, but I'll explain them later =)</p>

    <!-- scripts last, to make sure the page is "done" as much as possible, first -->
    <script>require(["builder", "buildTables", "addStyleSheet"], function(builder, buildTables, addStyleSheet) {"use strict";

      var y = -120;
      var outline = "M  20 "+(100 + y) + " L  20 "+(800 + y) + " 700 "+(800 + y) + " 700 "+(100 + y) + " 20 "+(100 + y)
                  + "M 170 "+(250 + y) + " L 550 "+(250 + y) + " 550 "+(650 + y) + " 170 "+(650 + y);
      outline = outline.replace(/\s+/g,' ');
      document.getElementById("svg").innerHTML = outline;

      var options = {
        outline: outline,
        label: "custom",
        minimal: false
      };

      var font = builder.build(options);
      addStyleSheet(font, "customfont", "custom");
      buildTables(font, window, "#tables", "custom font", "The byte layout views for our small, custom font.");

    });</script>
  </body>

</html>
