<!doctype html>
<html>

  <head>
    <meta charset="utf-8">
    <title>Let's make a font</title>
    <link rel="stylesheet" href="style.css">
  </head>

  <body>
    <h1>Let's make a small font</h1>

<!--
    <p>We all use fonts every day, and we don't even have to bother noticing. Text looks pretty
    (okay, sometimes it looks horrible) and that's pretty much the extent of our interaction with
    fonts. We take them for granted, and that's a good thing: they're not just easy to use, we
    simply don't care how they work because we don't need to. They just work, and we don't have
    to think about whatever complexities are involved in actually getting text styled using a
    specific font.</p>

    <p>But, sometimes you want to dive into a subject for a bit to find out how something that
    you take for granted in every day life works. How does your car's engine work? Where does
    milk come from? Why do clocks show 12 instead of 3, 6, or 24 steps? Do dolphins even sleep?</p>

    <p>Or, in this case, how does a font work? In order to best see how a font works, we're
    actually going to "roll our own" font. And not the simple kind either, we're going to
    make our own OpenType font (if you've ever seen a font file and it ended in .ttf or .otf,
    those are OpenType fonts. It's the defacto standard in font land), using Adobe Type2
    charstrings, which are a very rich —but also generally complex— way to specify vector
    graphics.</p>

    <h2>Let's look at a font from the ground up</h2>

    <p>First off, let's quickly generate a small font that we can use to examine how they're
    built up, and how they work:</p>
-->

    <!-- this gets replaced by the on-page script -->
    <div id="tables"></div>

    <p>plain test: <span style="font-family: 'custom font (small)';">~</span> (glyph "~", should be a rect. with cutout — a copy/paste should reveal "~")</p>

<!--
    <p>The above two tables are a font. Seriously! The table on the left shows you the bytecode
    for a custom font that was just made, right now, on this page. On the right the same bytecode has
    been turned into letters, but not every byte has a corresponding letter, because the <a
    href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">8859-1 codepage</a>, the standard
    byte-to-letter table on modern computers, doesn't assign a readable letter to every
    number that a byte can represent (which is the numbers 0 through 255). The bytecode
    00, for instance, has no equivalent letter, while bytecode 41 (representing a base-16
    value, so actually the decimal value 65) is the letter "A".</p>

    <p>So, let's test that font. If all went well, this is a little rectangle with a rectangular
    hole cut out of the center: <span style="font-family: 'custom font (small)';">~</span>. However, if
    you view the HTML code for this page, and you search for this paragraph, you'll see that
    it's actually the letter "A", with this tiny font applied to it. So... let's figure out
    why you saw a rectangle instead of the letter "A".</p>

    <h2>Fonts don't contain letters</h2>

    <p>It's a little unintuitive, but there are no letters in fonts. There sort-of are,
    but when you pop the bonnet and really look at what's going on, even the sort-of
    letters aren't really letters at all. Fonts contain, broadly speaking, three things
    that ultimate lead to you thinking there are letters in it:</p>

    <ol>
      <li>vector graphics representing, quite often, letters (but not always), each with their own id,</li>
      <li>a mapping from "virtual id" to one (or combination of more than one) vector graphic, and finally,</li>
      <li>a mapping from "keyboard code" to "virtual id"</li>
    </ol>

    <p>When you type a letter, your keyboard, operating system, and text engine conspire to turn
    your letter into an identifier. It's just a number (if you're lucky, it's the unicode number,
    but this has historically not been the case, and often still isn't), and that number is
    passed into the font, which finds the corresponding for-this-font-only virtual id, and then
    fetches one (or more) vector graphics that belong to that virtual id. If everything went well,
    the computer will now show you a graphic that matches what you expected it to look like. For
    instance, if you type "O", you (almost, but again not necessarily, always) expect to see a ring.
    If the font lacks a mapping for "from the computer" identifier to font-internal virtual id,
    then you usually see ? or an empty box. What really happens is that the font goes "I have no
    mapping for this. I will give you the graphics associated with the 'not defined' id". In
    font land this is called the .notdef glyph, and it's handy because it means the font will
    always be able to give something back to the computer to use. Your programs don't crash
    just because a font does not have one or more letters you want from it!</p>

    <h2>Styling text</h2>

    <p>When the text on this page says <code>[...] center: A. [...]</code>, the browser will ask
    the text engine to actually style the character code sequence <code>[...] 0x63 0x65 0x6E 0x74
    0x65 0x72 0x20 0x3A 0x20 0x41 0x2E [...]</code>, where the letter "c" is actually the code 0x63,
    "e" is 0x65, etc. Here's where the first "I did not expect that" thing happens. The text engine
    will not actually give you a picture for a code, and then move on to the next code, it's actually
    a fairly sophisticated instruction book, and they can come with a section on replacing more than
    one code with another. For instance, it might receive "c", then "e", and then n", and for each
    of these three it might give the text engine a picture (usually, a 'c', an 'e', and an 'n').
    However, if it then encounters the code for "t", and it has an entry that says "if you see 'cent',
    give the cent-as-currentcy picture" it will actually cause the text engine to throw away the things
    it got for "c", "e", and "n", and instead replace the entire sequence "cent" with this single
    picture. This is something you might expect your word processor to do, but in fact fonts fully
    have this capability built in.</p>

    <p>In this particular case, we're just giving it a single code, so no substitution is going to
    occur, but that doesn't mean it never will: we could have a font that has rules that say "when
    you see the code for A, replace that with the code for F, before continuing with finding the
    correct picture". You could have a font that has replacements for every letter so that if you
    write a normal text, it'll look like gibberish. Or, conversely, have a text that looks like
    gibberish, but when styled with that font is actually legible. You can do some pretty neat
    things with these substitution rules.</p>

    <p>In this case, our font is asked to style 0x41, the capital letter A. It has no substitution
    rules, so it has to look for the picture associated with code 0x41. But first it has to find out
    which internal code 0x41 maps to. There are quite a lot of different ways fonts can describe the
    mappings between "from the computer" codes and "internal to the font" codes; some of these are
    very simple, going "computer code X maps to internal code Y, and just assume that X+1 maps to
    Y+1 etc.", but others are really smart and complex for fonts that have lots of letters that
    don't have consecutive character code. This particular font uses one of the more complex
    character mappings, but for only a single letter, so it's not actually that difficult to find
    what the font's internal code is: the charactar map is one with multiple "segments" that each
    describes a mapping for a range of characters in such a way that even if the character codes
    aren't sequential, the internal codes will be. However, we only have one letter, which means
    we only have one segment, and it only has one rule: "segment 1 starts with character code 0x41,
    and maps to internal code 1."</p>

    <p>With this internal code, the font can actually look up the picture that belongs to our
    letter A. This is where design choice comes in: there are two "flavours" of opentype fonts,
    namely "truetype" fonts, and "type 2" (or "cff") fonts. The difference between the two is
    that the first uses a relatively simple way to find the pictures associated with internal
    codes, but the pictures use a fairly simple set of set of graphics instructions, so making
    beautiful or very precise shapes requires a lot of instructions per letter, making truetype
    fonts pretty big. The second kind has a more complicated way of dictating what pictures belong
    to internal codes, but the graphics instruction set is much richer, leading to much smaller
    fonts. The font we're using on this page is one of these "type 2" fonts. (note that they're
    called type 2 not because they are usually the second in the list of available flavours, but
    because they use Adobe's "type 2 charstring" format for the graphics instructions.)</p>
-->

<hr>

    <h1>Let's also make a larger with-GSUB font</h1>

    <!-- this gets replaced by the on-page script -->
    <div id="tables_small"></div>

    <p>GSUB test: <span class="liga" style="font-family: 'custom font (big)';">custom</span> (string "custom"; should also be a rect. with cutout — a copy/paste should reveal "custom")</p>

<!--
<pre>
    - glyph resolution
      - cff
        - font-in-a-font
          - charstrings
            - .notdef
            - our glyph
    - rendering
      - the picture isn't the metrics
        - height/width
        - line heights
          - overlaps
          - quad sizes
</pre>
-->

    <script src="Mapper.js"></script>
    <script src="dataBuilding.js"></script>
    <script src="Tables.js"></script>
    <script>
      Array.prototype.first = function() { return this[0]; };
      Array.prototype.last = function() { return this[this.length-1]; };
      NodeList.prototype.array = function() { return Array.prototype.slice.call(this); };
      NodeList.prototype.forEach = Array.prototype.forEach;
    </script>
    <script src="buildTablesNow.js"></script>
    <script>
      buildTables(this, false, "#tables", "custom font (small)", "A minimal, full spec-conforming OpenType font");
      buildTables(this, true, "#tables_small", "custom font (big)", "A more legible version of our full spec-conforming OpenType font");
    </script>
  </body>

</html>
