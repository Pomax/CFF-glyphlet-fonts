<!doctype html>
<html>

  <head>
    <meta charset="utf-8">
    <title>Let's make a font</title>
    <link rel="stylesheet" href="style.css">
    <script src="dataBuilding.js"></script>
    <script src="Tables.js"></script>
    <script>
      NodeList.prototype.array = function() { return Array.prototype.slice.call(this); };
    </script>
  </head>

  <body>
    <h1>Let's make a font</h1>

    <p>We all use fonts every day, and we don't even have to bother noticing. Text looks pretty
    (okay, sometimes it looks horrible) and that's pretty much the extent of our interaction with
    fonts. We take them for granted, and that's a good thing: they're not just easy to use, we
    simply don't care how they work because we don't need to. They just work, and we don't have
    to think about whatever complexities are involved in actually getting text styled using a
    specific font.</p>

    <p>But, sometimes you want to dive into a subject for a bit to find out how something that
    you take for granted in every day life works. How does your car's engine work? Where does
    milk come from? Why do clocks show 12 instead of 3, 6, or 24 steps? Do dolphins even sleep?</p>

    <p>Or, in this case, how does a font work? In order to best see how a font works, we're
    actually going to "roll our own" font. And not the simple kind either, we're going to
    make our own OpenType font (if you've ever seen a font file and it ended in .ttf or .otf,
    those are OpenType fonts. It's the defacto standard in font land), using Adobe Type2
    charstrings, which are a very rich —but also generally complex— way to specify vector
    graphics.</p>

    <h2>Let's look at a font from the ground up</h2>

    <p>First off, let's quickly generate a small font that we can use to examine how they're
    built up, and how they work:</p>

    <script src="buildTablesNow.js"></script>

    <p>The above two tables are a font. Seriously! The table on the left shows you the bytecode
    for a custom font that was just made, right now, on this page. On the right the same bytecode has
    been turned into letters, but not every byte has a corresponding letter, because the <a
    href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">8859-1 codepage</a>, the standard
    byte-to-letter table on modern computers, doesn't assign a readable letter to every
    number that a byte can represent (which is the numbers 0 through 255). The bytecode
    00, for instance, has no equivalent letter, while bytecode 41 (representing a base-16
    value, so actually the decimal value 65) is the letter "A".</p>

    <p>So, let's test that font. If all went well, this is a black rectangle:
    <span style="font-family: 'custom font';">A</span>. If you do a view-source on
    this index.html, you'll see that it's actually the "letter" A, with this
    tiny font applied to it. So... let's figure out <strong><em>WHY</em></strong>
    you saw a rectangle instead of the capital letter 'A'.</p>

    <h2>Fonts don't contain letters</h2>

    <p>It's a little unintuitive, but there are no letters in fonts. There sort-of are,
    but when you pop the bonnet and really look at what's going on, even the sort-of
    letters aren't really letters at all. Fonts contain, broadly speaking, three things
    that ultimate lead to you thinking there are letters in it:</p>

    <ol>
      <li>vector graphics representing, quite often, letters (but not always), each with their own id,</li>
      <li>a mapping from "virtual id" to one (or combination of more than one) vector graphic, and finally,</li>
      <li>a mapping from "keyboard code" to "virtual id"</li>
    </ol>

    <p>When you type a letter, your keyboard, operating system, and text engine conspire to turn
    your letter into an identifier. It's just a number (if you're lucky, it's the unicode number,
    but this has historically not been the case, and often still isn't), and that number is
    passed into the font, which finds the corresponding for-this-font-only virtual id, and then
    fetches one (or more) vector graphics that belong to that virtual id. If everything went well,
    the computer will now show you a graphic that matches what you expected it to look like. For
    instance, if you type "O", you (almost, but again not necessarily, always) expect to see a ring.
    If the font lacks a mapping for "from the computer" identifier to font-internal virtual id,
    then you usually see ? or an empty box. What really happens is that the font goes "I have no
    mapping for this. I will give you the graphics associated with the 'not defined' id". In
    font land this is called the .notdef glyph, and it's handy because it means the font will
    always be able to give something back to the computer to use. Your programs don't crash
    just because a font does not have one or more letters you want from it!</p>

  </body>

</html>
